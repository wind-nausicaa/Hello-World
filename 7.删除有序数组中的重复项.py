# 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

# 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：

# 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
# 返回 k 。
# 判题标准:

# 系统会用下面的代码来测试你的题解:

# int[] nums = [...]; // 输入数组
# int[] expectedNums = [...]; // 长度正确的期望答案

# int k = removeDuplicates(nums); // 调用

# assert k == expectedNums.length;
# for (int i = 0; i < k; i++) {
#     assert nums[i] == expectedNums[i];
# }
# 如果所有断言都通过，那么您的题解将被 通过。

 

# 示例 1：

# 输入：nums = [1,1,2]
# 输出：2, nums = [1,2,_]
# 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
# 示例 2：

# 输入：nums = [0,0,1,1,1,2,2,3,3,4]
# 输出：5, nums = [0,1,2,3,4]
# 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 

# 提示：

# 1 <= nums.length <= 3 * 104
# -104 <= nums[i] <= 104
# nums 已按 非严格递增 排列

class Solution:
    def removeDuplicates(self, nums: list[int]) -> int:
        # # 解题思路：
        # # 已经按照非严格递增顺序排列了，所以依次判断每个元素是否和上一个元素一致，如果一致则跳过，并用不一致的数据补充上来，因此用一个循环遍历数组，用一个指针指示需要被覆盖的数组位置即可，在原数组上操作
        # # 遍历变量i，从第二个数字开始遍历，直到i = len(nums) - 2遍历完成为止
        # i = 0
        # # 指针p指向下一个需要被替换的位置，初始值为第2个数字
        # p = 1
        # # 空数组单独处理，直接return
        # if len(nums) == 0:
        #     p = 0
        # else:
        #     # 进入循环
        #     while(True):
        #         # 当i指向最后一个元素，那么就不用再判断了，条件放前面是为了避免数组访问越级的情况，比如空数组或只有1个数字，实际上空数组这里传不进来
        #         if i == len(nums) - 1:
        #             break
        #         # 如果下一个数字和上一个数字不一致
        #         if nums[i + 1] != nums[i]:
        #             # 则下个数字为目标数字，用这个数字替换掉需要替换的位置
        #             nums[p] = nums[i + 1]
        #             # 指针指向下一个位置，同时p也是一个计数器，替换了多少次就代表有多少个不重复的数字
        #             p += 1
        #         # 如果一致，则没法填充，则继续遍历下一个数字，这里无需操作，故不用写判断条件
        #         i += 1
        # return p

        # 利用remove()，换一种思路，不填充数组，改成删除数组，把重复值给删掉
        i = 0
        # 这里p表示剩余的数字
        p = 1
        # 将数组原长度存起来，免得删掉后获取长度不准
        l = len(nums)
        # 判断数组是否为0，为0则p也为0
        if l == 0:
            p = 0
        else:
            while(True):
                # 当循环到最后一个数字后，则停下来
                if i == l - 1:
                    break
                # 如果上一个数字和下一个数字一样
                if nums[p] == nums[p - 1]:
                    # 则把下一个数字删掉
                    nums.pop(p)
                # 如果上一个数字和下一个数字不一样，则留存数字数量 + 1，同时p指向下一个位置
                else:
                    p += 1
                # 如果不一样，则无需操作，直接过渡到下一个位置，数组是变动的，不能用i来当作一个指针，仅作循环使用
                i += 1
        return p